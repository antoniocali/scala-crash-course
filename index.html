<!doctype html>
<html lang="en-en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Scala Crash Course</title>

    <meta name="description" content="A Scala Crash Course">
    <meta name="author" content="Antonio Davide Cali">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/nord.css">
</head>

<body>
<div class="reveal">
    <div class="slides">
        <section data-background-image="img/logo.png" data-background-size="50px"
                 data-background-position="left 15px top 15px">
            <h1>Scala Crash Course</h1>
            Author: Antonio Davide Cali<br/>
            &lt;antonio.davide.cali@lego.com&gt;

        </section>
        <section>
            <section data-markdown>
					<textarea data-template>
					 # Agenda
					- Local Dev environment
					- Hello World
					- val, var, def, lazy val
					- Types
					- Control Structures
					- HoF
					- ...
				</textarea>

            </section>
            <section data-markdown>
					<textarea data-template>
					- Collections
					- For Comprehensions
					- Functions Currying
					- OOP (Class vs Objects)
					- Traits
					- Option
					- Try

				</textarea>
            </section>
        </section>
        <section>
            <section>
                <h2>Local Dev environment</h2>
                <p>Ready Made Set-up: Coursier <br/>
                    Get at: <a href="https://get-coursier.io/docs/cli-installation">get-coursier.io</a></p>
                Ready made script
                <pre><code data-trim class="language-bash">
					$ brew install coursier/formulas/coursier
					$ cs setup
				</code></pre>
            </section>
            <section>
                <h2>IDE</h2>
                <p>JetBrains IntelliJ<br/>
                    Scala Plugin
                </p>
                <img class="r-stretch" data-src="img/intellij.png">
            </section>
            <section>
                <p>Check everything works</p>
                <pre>
						<code class="language-bash" data-trim>
							$ sbt --version                                                                                                                                    ─╯
							> sbt script version: 1.3.13
							$ java -version
							> "1.8.0_282"
						</code>
					</pre>
                <p>We are ready</p>
            </section>
        </section>
        <section>
            <section>
                <p>New Project</p>
                <pre>
					<code class="language-bash" data-trim>
					$ mkdir scala
					$ cd scala
					$ sbt new scala/scala3.g8
					$ idea scala-crash-course
				</code>
				</pre>
                <p>open <code>src/main/Main.scala</code><br></p>
            </section>
            <section>
                <h3>Hello World</h3>
                <pre><code data-trim>
					object Main extends App {
						println("Hello World")
					}
				</code></pre>
            </section>
        </section>
        <section>
            <section>
                <h2>Keywords</h2>
                <ul>
                    <li><code>var</code>: evaulate immediatly, possible to re-assign</li>
                    <li><code>val</code>: evaulate immediatly, <strong>NOT</strong> possible to re-assign</li>
                    <li><code>def</code>: function declaration, evaulate on call</li>
                    <li><code>lazy val</code>: evaluate on demand and only once</li>
                </ul>
            </section>
            <section>
                <p>On Code</p>
                <pre>
						<code data-trim class="language-scala">
							object Main extends App {

								val myVal = {
								  println("This is a val")
								  1
								}
							  
								var myVar = {
								  println("This is a var ")
								  2
								}
							  
								def myDef = {
								  println("This is a function")
								  3
								}
							  
								lazy val myLazyVal = {
								  println("This is lazy val")
								  4
								}
							  
								println(myVal)
								println(myVar)
								println(myDef)
								println(myLazyVal)
								// Calling again
								println(myLazyVal)
							  }
						</code>
					</pre>
            </section>
            <section>
                <p>It produces followig output</p>
                <pre>
						<code data-trim class="language-bash">
							This is a val
							This is a var 
							1
							2
							This is a function
							3
							This is lazy val
							4
							4
						</code>
					</pre>

            </section>

        </section>
        <section>
            <section>
                <h1>Types</h1>
                <p>Everything in Scala is a Type.</p>
                <ul>
                    <li><code>Boolean</code></li>
                    <li><code>Long, Int, Short, Byte</code></li>
                    <li><code>Double, Float</code></li>
                    <li><code>Char</code></li>
                    <li><code>Unit</code> (WHAT?)</li>
                </ul>
            </section>
            <section>
                <h3>Scala Type Hierarchy</h3>
                <img class="r-stretch" data-src="img/unified-types-diagram.svg">
                <p>Yup, there's a bottom type: <code>Nothing</code></p>
                <p>And yes, we do have <code>Null</code> type</p>
            </section>

            <section>
                <h1>Type Alias</h1>
                <pre>
					<code data-trim class="scala">
						type StatusCode = Int
  
						def myPost: StatusCode = 200
					</code>
					</pre>
            </section>
        </section>
        <section>
            <section>
                <h3>Control Structures</h3>
                <ul>
                    <li><code>if/else</code></li>
                    <li><code>for</code> loops</li>
                    <li><code>match</code> expressions</li>
                    <li><code>try/catch/finally</code></li>
                    <li>Custom control Structures?!</li>
                </ul>
            </section>
            <section>
                <p><code>if else</code> is an expression. Last line is returned</p>
                <pre>
						<code data-trim class="scala" data-line-numbers="1-2|2-8">
							def numberType(x: Int): String =
								if (x < 0) {
									"negative"
								} else if (x == 0) {
									"zero"
								} else {
									"positive"
								}
						</code>
					</pre>
            </section>
            <section>
                <code>for</code> loops and guards. GG EZ
                <pre><code data-trim class="scala" data-line-numbers="1-7|3|4|6|1-7">
						val ints = List(1, 2, 3, 4, 5)
						for {
						  i <- ints
						  if i > 2
						} {
						  println(i)
						}
					  
						</code>
						</pre>
                <p>output</p>
                <pre>
						<code data-trim class="bash">
							3
							4
							5
						</code>
					</pre>
            </section>
            <section>
                <h3>Match</h3>
                <p>Match expression is like your best tool<small>
                    and it's an expression
                </small></p>
                <pre><code data-trim class="scala" data-line-numbers="1-8|3|4-6|1-8">
						val i = 5
						val result: String = 
							i match {
								case 1 => "one"
								case 2 => "two"
								case _ => "other"
							}
						// result yield "other"
					</code></pre>
            </section>
            <section>
                More on match
                <pre>
						<code data-trim class="scala">
							// getClassAsString is a method 
							// that takes a single argument of any type.
							def getClassAsString(x: Any): String = 
								x match {
									case s: String => s"'$s' is a String"
									case i: Int => "Int"
									case d: Double => "Double"
									case l: List[_] => "List"
									case _ => "Unknown"
								}

							// examples
							getClassAsString(1)               // Int
							getClassAsString("hello")         // 'hello' is a String
							getClassAsString(List(1, 2, 3))   // List
						</code>
					</pre>
            </section>
            <section>
                more matches, sounds like Tinder at this point
                <pre>
						<code data-trim class="scala" data-line-numbers="1-13|1|5-6|7-8|9|1-13">
							case class Person(name: String, age: Int)

							def speak(p: Person): Unit = 
								p match
									case Person("Antonio", _) =>
										println(s"Yes it's me, Antonio")
									case p @ Person(_, age) if age > 30 =>
										println(s"${p.name} is practically dead")
									case _ => println("Watch the Flintstones!")
							
							speak(Person("Fred", 100)) // "Fred is practically dead"
							speak(Person("Antonio", 32)) // "Yes it's me, Antonio"
							speak(Person("Whatever", 10)) // "Watch the Flintstones!"
						</code>
					</pre>
            </section>
            <section>
                <p><code>try/catch/finally</code><small>the old fashion pattern</small></p>
                <pre class="fragment">
					<code class="scala" data-trim>
						try {
							writeTextToFile(text) //pre-defined
						} 
						catch {
							case ioe: IOException =>
							  println("Got an IOException.")
							case nfe: NumberFormatException =>
							  println("Got a NumberFormatException.")
						}
						finally {
							println("Clean up your resources here.")  
						}

					</code>
				</pre>
                <p class="fragment">Later we fix this S?!t</p>
            </section>
            <section>
                <h3>Building our Control Structure</h3>
                <pre class="fragment">
						<code data-trim class="scala" data-line-numbers="1-11|1-3|5-7|1-11">
						def loop(times: Int)(f: Int => Unit): Unit = {
							for (index <- 0 to times) f(index)
						}
						
						loop(3) { index =>
							println(s"this is my $index time I got executed")
						}

						// this is my 0 time I got executed
						// this is my 1 time I got executed
						// this is my 2 time I got executed
						</code>
					</pre>
                <p class="fragment">Possible because Currying and Syntactic Sugar</p>
            </section>
        </section>
        <section data-state="make-it-pop">
            <section>
                <h4>Time to have Fun<small class="fragment">ctions</small></h4>
                <p class="fragment">Scala is a very Functional Programming Language</p>
                <p class="fragment">Functions are first citizens</p>
            </section>
            <section>
                <p>Functions now are objects like all other types we saw.</p>
                <pre>
						<code data-trim class="scala">
							val doubled: (Int) => Int = (elem: Int) => elem*2
							println(doubled(2)) // 4
						</code>
					</pre>
                <p class="fragment">Type of <code>doubled</code> is <code>(Int) => Int</code>.
                    <br/>Behind the scene Scala transform this Type into a <code>Function2[Int, Int] object.</code>
                </p>
            </section>
            <section>
                <h3>Higher&dash;Ordered Function</h3>
                <p>It means now we can pass functions to functions</p>
                <pre>
					<code data-trim class="scala fragment">
						val doubled: (Int) => Int = (elem: Int) => elem*2
						val salaries: List[Int] = List(10, 20, 30)
						salaries.map(doubled) // List(20, 40, 60)
					</code>
				</pre>
            </section>
            <section>
                <p>... and return functions from functions</p>
                <pre>
					<code data-trim class="scala fragment">
						def sslBuilder(isSSL: Boolean): (String) => String = {
							val schema = if (isSSL) "https://" else "http://"
							(domain: String) => schema + domain
						}
						
						def getUrl: (String) => String = sslBuilder(isSSL = true)
						val url = getUrl("www.lego.com") // "https://www.lego.com"
					</code>
				</pre>
            </section>
            <section><p>But MOM, I don't want to pre-define functions to use them.<br/>
                We can use anonymous functions</p>
                <pre>
				<code data-trim class="scala fragment" data-line-numbers="1-6|3|4-6|1-6">
					val doubled: (Int) => Int = (elem: Int) => elem*2
					val salaries: List[Int] = List(10, 20, 30)
					salaries.map(doubled) 				// List(20, 40, 60)
					salaries.map((i: Int) => i * 2) 	// List(20, 40, 60)
					salaries.map(i => i * 2)			// List(20, 40, 60)
					salaries.map(_ * 2)					// List(20, 40, 60)
				</code>
			</pre>
            </section>
        </section>
        <section>
            <section>
                <h3>Collections</h3>
                <ul>
                    <li>Sequences: sequential collection of elements - indexed (like an array) or linear (like a linked
                        list)
                    </li>
                    <li>Map: a collection of key/value pairs, like a Java <code>Map</code>, Python
                        <code>dictionary</code></li>
                    <li>Set: unordered collection of unique elements</li>
                </ul>
            </section>
            <section>
                <h3>Seq - List</h3>
                <p>Creating a list</p>
                <pre>
					<code data-trim class="scala">
			val ints = List(1, 2, 3)
			val names = List("Joel", "Chris", "Ed")

			// another way to construct a List
			val namesAgain = "Joel" :: "Chris" :: "Ed" :: Nil
					</code>
				</pre>
                <aside class="notes">:+ and +:</aside>
            </section>
            <section>
                <p>Add an element a list</p>
                <pre>
					<code data-trim class="scala">
			val a = List(1, 2, 3)
			val b = 0 :: a              // List(0, 1, 2, 3)
			val c = List(-1, 0) ::: a   // List(-1, 0, 1, 2, 3)
					</code>
				</pre>
                <p><code>::</code> prepend a element <br/><code>:::</code> prepend a list</p>
            </section>
            <section>
                <p><code>Common List Methods</code></p>
                <pre>
					<code data-trim class="scala">
			val names = List("Antonio", "Jenny",
						"Philip", "Oliver", "Soren", "Josephine")
			names.head // "Antonio"
			names.last // "Josephine"
			names.slice(from = 2, until = 4) // List(Philip, Oliver)
			names.drop(2) // List(Philip, Oliver, Soren, Josephine)
			names.take(2) // List(Antonio, Jenny)

					</code>
				</pre>
            </section>
            <section>
                <p>HoF on Collections<small>One for all</small></p>
                <pre>
					<code data-trim class="scala">
			val names = List("Antonio", "Jenny",
						"Philip", "Oliver", "Soren", "Josephine")
			names.map(_.length) // List(7, 5, 6, 6, 5, 9)
			names.filter(_.contains("o")) // List(Antonio, Soren, Josephine)
			names.dropWhile(_.contains("n")) // List(Philip, Oliver, Soren, Josephine)
			names.find(_.contains("l")) // Some(Philip)
			names.map(_.length).filter(_ < 7).reduce((a, b) => a + b) // 22
			names.foreach(println) // ???
			names.head.map(_.toString).toList // List(A, n, t, o, n, i, o)
			names.map(_.length).map(elem => List(elem-1, elem, elem+1)) // List(List(6, 7, 8), List(4, 5, 6), List(5, 6, 7), List(5, 6, 7), List(4, 5, 6), List(8, 9, 10))
					</code>
				</pre>
                <aside class="notes"><code>names.scanLeft("")((b,a) => b + a.head.toString.toUpperCase)</code></aside>
            </section>
            <section>
                <h3>Maps</h3>
                <pre>
					<code data-trim class="scala">
			val states = Map(
			  "it" -> "Italia",
			  "dk" -> "Denmark"
			)
			for (k, v) <- states do println(s"key: $k, value: $v")
			val moreStates = states + ("en" -> "England") // Map(it -> Italia, dk -> Denmark, en -> England)
			val evenMore = moreStates ++ Seq("es" -> "Spain", "de" -> "Germany") // HashMap(de -> Germany, en -> England, es -> Spain, IT -> Italia, DK -> Denmark)
			val removed = moreStates - "en" // Map(IT -> Italia, DK -> Denmark)
					</code>
				</pre>
                <aside class="notes">Some Map, Filter and foreach.</aside>
            </section>
            <section>
                <h3>Sets</h3>
                <pre>
					<code data-trim class="scala">
			val emptyNums = Set[Int]()
			val letters = Set('a', 'b', 'c', 'c')   // Set(a, b, c)
			val moreLetters = letters + 'd' // Set(a, b, c, d)
			letters intersect Set('b') // Set(b)
					</code>
				</pre>
                <aside class="notes">Some Map, Filter and foreach.</aside>
            </section>
        </section>
        <section>
            <section>
                <h3>for comprehension</h3>
                <p>It's a lightweight notation for expressing sequence comprehensions </p>
                <p>Basic Syntax: <code class="scala">for (enumerators) <strong>yield</strong> e</code></p>
            </section>
            <section>
                <p>Some examples</p>
                <pre>
					<code data-trim class="scala">
	val chessBoard = for {
		letter <- 'A' to 'H'
		number <- 1 to 8
	} yield s"$letter$number"

	chessBoard.foreach(println)
					</code>
				</pre>
            </section>
            <section>
				<pre>
					<code data-trim class="scala">
case class User(name: String, age: Int)

val userBase = List(
  User("Travis", 28),
  User("Kelly", 33),
  User("Jennifer", 44),
  User("Dennis", 23))

val twentySomethings =
  for user <- userBase if user.age >=20 && user.age < 30
  yield user.name  // i.e. add this to a list

twentySomethings.foreach(println)  // prints Travis Dennis
					</code>
				</pre>
            </section>
            <section><h4>Important</h4>
                <p>I know it sounds weird but <code><strong>for</strong> comprehension</code> is just <em>syntactic
                    sugar</em> in Scala to a sequence of calls to one or more of the methods:</p>
                <ul>
                    <li>foreach</li>
                    <li>map</li>
                    <li>flatMap</li>
                    <li>withFilter</li>

                </ul>
            </section>
			<section>
				<p>Sugar-free example</p>
				<pre><code class="scala" data-trim>
val chessBoard = for {
	letter <- 'A' to 'H'
	number <- 1 to 8
} yield s"$letter$number"

val deSugarIt =
	('A' to 'H').flatMap(letter =>
		(1 to 8)
			.map(number => s"$letter$number")
  )
				</code></pre>
			</section>
        </section>

    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/

    Reveal.initialize({
        hash: true,
        slideNumber: "h/v",
        overview: true,
        showNote: true,
        transition: 'fade',
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });

</script>
</body>

</html>